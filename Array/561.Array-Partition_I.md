> 题目：给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。
> 返回**最大总和**。

这道题不太好理解，甩一个例子。

> 输入：nums = [6,2,6,5,1,2]
> 输入：9
> 解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9

这道题有点田忌赛马的感觉，关键是谁跟谁组队。题意是，组队后，将每种可能的每组的最小值加起来，求最大的那一个。因此必须尽可能保留大的值，试想一下，若最小的跟最大的组队，那么最大值就会被舍去，若第二大跟第二小的组队，那么第二大的就回被舍去。所以发现应该最小的跟第二小的组队，第三小的跟第四小的组队，这样损失才最小，于是求得的结果也就最大了。

代码如下：

```java
public class ArrayPartitionI {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);  // 排序
        int sum =0;
        for(int i = 0; i < nums.length; i += 2){
            sum += nums[i];  // 将奇数索引的数相加
        }
        return sum;
    }
}

```
